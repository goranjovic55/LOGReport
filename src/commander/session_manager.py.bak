"""
Session Manager
Handles Telnet, VNC, and FTP session connections
"""
import telnetlib
import socket
import time
import re
import logging
from enum import Enum
from dataclasses import dataclass
from typing import Optional
from .models import NodeToken

class SessionType(Enum):
    TELNET = "TELNET"
    VNC = "VNC"
    FTP = "FTP"

@dataclass
class SessionConfig:
    host: str
    port: int
    session_type: SessionType
    username: str = ""
    password: str = ""
    timeout: int = 15

class BaseSession:
    """Abstract base class for session connections"""
    def __init__(self, config: SessionConfig):
        self.config = config
        self.connection = None
        self.is_connected = False
        
    def connect(self):
        raise NotImplementedError("Subclasses must implement connect()")
    
    def disconnect(self):
        if self.is_connected:
            try:
                self._disconnect_impl()
            finally:
                # Ensure state is reset even if disconnection fails
                self.is_connected = False
        self.connection = None
    
    def _disconnect_impl(self):
        """Implementation-specific disconnect logic"""
        raise NotImplementedError("Subclasses must implement _disconnect_impl()")
    
    def send_command(self, command: str) -> str:
        raise NotImplementedError("Subclasses must implement send_command()")
    
    def get_current_state(self) -> str:
        """Returns a string representation of connection state"""
        return f"{self.config.session_type.name} - {'Connected' if self.is_connected else 'Disconnected'}"

class TelnetSession(BaseSession):
    def __init__(self, config: SessionConfig):
        super().__init__(config)
        self.buffer = b""
        
    def connect(self) -> bool:
        try:
            # Log connection parameters
            logging.debug(f"TelnetSession.connect: Connecting to {self.config.host}:{self.config.port} with timeout={self.config.timeout}")
            
            # Establish connection with increased timeout
            self.connection = telnetlib.Telnet(
                self.config.host,
                self.config.port,
                self.config.timeout
            )
            
            # Detailed socket info
            sock = self.connection.get_socket()
            logging.debug(f"TelnetSession.connect: Socket created: {sock}")
            logging.debug(f"TelnetSession.connect: Socket timeout: {sock.gettimeout()}")
            
            # Wait for initial connection and read any banner
            time.sleep(1.0)  # Increased for Windows compatibility
            
            # Read initial banner/response
            initial_response = self.connection.read_very_eager()
            logging.debug(f"TelnetSession.connect: Initial response (hex): {initial_response.hex()}")
            logging.debug(f"TelnetSession.connect: Initial response (text): {initial_response.decode('ascii', 'ignore')}")
            
            # Skip artifact clearing for now to isolate connection issue
            logging.debug("TelnetSession.connect: Skipping artifact clearing for debug")
            
            self.is_connected = True
            logging.info("TelnetSession: Connection established successfully")
            return True
            
        except socket.timeout as e:
            logging.error("Telnet connection timed out", exc_info=True)
            return False
        except ConnectionRefusedError as e:
            logging.error("Telnet connection refused", exc_info=True)
            return False
        except Exception as e:
            logging.error(f"Telnet connection failed: {str(e)}", exc_info=True)
            return False
    
    def _disconnect_impl(self):
        if self.connection:
            try:
                # Properly close and terminate the telnet connection
                self.connection.close()
                # Additional cleanup to ensure complete disconnection
                if hasattr(self.connection, 'get_socket'):
                    sock = self.connection.get_socket()
                    if sock:
                        sock.shutdown(socket.SHUT_RDWR)
                        sock.close()
            except Exception as e:
                print(f"Error closing telnet connection: {str(e)}")
            finally:
                self.connection = None
    
    def send_command(self, command: str, timeout: float = 5.0) -> str:
        """Standardized command sending matching TelnetClient implementation"""
        if not self.is_connected:
            error_msg = "TelnetSession.send_command: Not connected to Telnet session"
            logging.error(error_msg)
            raise ConnectionError(error_msg)

        logging.debug(f"TelnetSession.send_command: Sending command: {command}")
        try:
            # Clear input buffer and console artifacts
            logging.debug("TelnetSession.send_command: Clearing input buffer")
            self.connection.read_very_eager()
            self.connection.write(b'\x18')  # Ctrl+X
            time.sleep(0.1)
            self.connection.write(b'\x1A')  # Ctrl+Z
            time.sleep(0.1)
            cleared = self.connection.read_very_eager()
            logging.debug(f"TelnetSession.send_command: Cleared {len(cleared)} bytes from buffer")

            # Send command with proper termination
            cmd_bytes = command.encode('ascii')
            # Ensure proper Telnet line endings (RFC 854)
            if not cmd_bytes.endswith(b'\r\n'):
                cmd_bytes = cmd_bytes.rstrip(b'\n') + b'\r\n'
            
            logging.debug(f"TelnetSession.send_command: Sending {len(cmd_bytes)} bytes: {cmd_bytes}")
            try:
                # telnetlib.write() returns None, so we don't check bytes_sent
                self.connection.write(cmd_bytes)
                logging.debug(f"TelnetSession.send_command: Command sent successfully")
            except (OSError, AttributeError) as e:
                error_msg = f"TelnetSession.send_command: Write failed: {str(e)}"
                logging.error(error_msg)
                raise ConnectionError(error_msg) from e
            
            # Get and process response using same method as TelnetClient
            response = self._read_response(timeout)
            logging.debug(f"TelnetSession.send_command: Received {len(response)} chars of raw response")
            
            processed = self._process_response(response, command)
            logging.debug(f"TelnetSession.send_command: Processed response length: {len(processed)}")
            return processed
            
        except socket.timeout as e:
            error = f"Error: Command timed out - {str(e)}"
            logging.error(f"TelnetSession.send_command: {error}")
            return error
        except Exception as e:
            error = f"Error: {str(e)}"
            logging.error(f"TelnetSession.send_command: {error}", exc_info=True)
            return error

    def _read_response(self, timeout: float) -> str:
        """Read telnet response with prompt detection"""
        response = b""
        start_time = time.time()
        last_data_time = time.time()
        
        logging.debug(f"TelnetSession._read_response: Starting read with timeout={timeout}s")
        
        while (time.time() - start_time) < timeout:
            chunk = self.connection.read_very_eager()
            if chunk:
                response += chunk
                last_data_time = time.time()
                decoded = response.decode('ascii', 'ignore')
                logging.debug(f"TelnetSession._read_response: Received {len(chunk)} bytes, total {len(response)}")
                
                if self.prompt_pattern.search(decoded):
                    logging.debug("TelnetSession._read_response: Detected prompt pattern")
                    break
                    
            # Use non-blocking wait instead of sleep
            self.connection.get_socket().settimeout(0.05)
            try:
                test_byte = self.connection.get_socket().recv(1)
                if test_byte == b'':
                    logging.debug("TelnetSession._read_response: Socket closed by remote")
                    break
            except socket.timeout:
                # Check if we've had no data for too long
                if (time.time() - last_data_time) > (timeout / 2):
                    logging.warning("TelnetSession._read_response: No data received for half of timeout period")
                    break
                continue
            except EOFError as e:
                logging.error(f"TelnetSession._read_response: EOFError - {str(e)}")
                break
            except Exception as e:
                logging.error(f"TelnetSession._read_response: Error reading socket - {str(e)}")
                break
                
        result = response.decode('ascii', 'ignore') if response else ""
        logging.debug(f"TelnetSession._read_response: Returning {len(result)} chars")
        return result

    def _process_response(self, response: str, command: str) -> str:
        """Process and clean the telnet response"""
        # Remove command echo
        clean = response.replace(f"{command}\r\n", "")
        # Remove prompt and extra whitespace
        clean = re.sub(r'\d+[a-z]\%\s*$', '', clean).strip()
        return clean

# Placeholders for other session types
class VNCSession(BaseSession):
    def connect(self):
        # Will be implemented in Phase 2
        self.is_connected = True
        return True
    
    def _disconnect_impl(self):
        pass
    
    def send_command(self, command: str) -> str:
        # In VNC we don't send commands directly
        return "VNC commands sent as keyboard sequences"

class FTPSession(BaseSession):
    def connect(self):
        # Will be implemented in Phase 2
        self.is_connected = True
        return True
    
    def _disconnect_impl(self):
        pass
    
    def send_command(self, command: str) -> str:
        # FTP commands are handled directly via protocol
        return "FTP commands not supported in this way"

class SessionManager:
    """Creates and manages active sessions"""
    session_types = {
        SessionType.TELNET: TelnetSession,
        SessionType.VNC: VNCSession,
        SessionType.FTP: FTPSession
    }

    def validate_token(self, token: NodeToken) -> bool:
        """Validate token structure and permissions"""
        if not token or not token.token_id:
            return False
        if len(token.token_id) != 3 or not token.token_id.isdigit():
            return False
        return True
    
    def __init__(self):
        self.active_sessions = {}
        self.session_counter = 0
        
        
    def create_session(self, config: SessionConfig, auto_connect=True) -> Optional[BaseSession]:
        """Creates a new session, optionally connecting immediately"""
        logging.debug(f"SessionManager.create_session: Creating session for {config.session_type.name} to {config.host}:{config.port}")
        session_class = self.session_types.get(config.session_type)
        if not session_class:
            raise ValueError(f"Unsupported session type: {config.session_type}")
        
        session = session_class(config)
        session_key = f"{config.session_type.name}_{self.session_counter}"
        self.session_counter += 1
        
        if auto_connect:
            if session.connect():
                self.active_sessions[session_key] = session
                logging.debug(f"SessionManager.create_session: Session created and connected: {session_key}")
                return session
            logging.error(f"SessionManager.create_session: Failed to connect session: {session_key}")
            return None
        
        # Not auto-connect - just store it
        self.active_sessions[session_key] = session
        logging.debug(f"SessionManager.create_session: Session created (not auto-connected): {session_key}")
        return session
    
    def get_or_create_session(self, session_key: str, session_type: SessionType, config: SessionConfig) -> Optional[BaseSession]:
        """Get existing session or create a new one if it doesn't exist"""
        if existing := self.get_session(session_key):
            return existing
            
        return self.create_session(config, auto_connect=True)
    
    def get_session(self, session_key: str) -> Optional[BaseSession]:
        """Retrieves an active session"""
        return self.active_sessions.get(session_key)
    
    def close_session(self, session_key: str):
        """Closes a specific session"""
        if session := self.active_sessions.get(session_key):
            session.disconnect()
            del self.active_sessions[session_key]
    
    def close_all_sessions(self):
        """Closes all active sessions"""
        for session in list(self.active_sessions.values()):
            session.disconnect()
        self.active_sessions = {}
        
    def get_all_sessions(self) -> dict:
        """Returns all active sessions"""
        return self.active_sessions.copy()
